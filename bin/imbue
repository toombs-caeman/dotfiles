#!/usr/bin/env nu

# TODO:
# * what happens if a platform can't be determined?
#   * can we have a default platform name?
# * show some help text if run without any work to do?
# * collapse template/ into main dir to eliminate source: ??
#   * gives us a nicer watch
# * rename template key to commands?
# * tagline: a sane, mustachioed, dotfile configuration manager

# print the version
def 'main version' [] { '0.0.1' }

let defaultpath = (match ($nu.os-info.name) {
    windows => "~/AppData/Local/imbue/config.yaml",
    linux => "~/.config/imbue/config.yaml",
})

# a dotfile rendering tool
#
# Features:
# * store your dotfiles in a git repo and render them out to where they need to go
# * install and configure your tools in one step with `imbue -i`
# * platform dependant installation and file destinations
# * by default, won't overwrite changes made to non-local files
# * dotfiles are rendered as {{moustache}} templates
#
# The configuration file looks like this:
# ```yaml 
# source: templates/    #<- A path relative to the config file's directory
#                       #   where all the dotfiles are kept in version control.
# detect:                               #<- the detect block is used to determine
#   win: which winget | is-not-empty    #   which 'platform' is currently being run.
#   nix: which pacman | is-not-empty    #   The values here are nushell boolean expressions.
#   mac: which brew | is-not-empty      #   The first one in order to evaluate to true is used.
# install:                  #<- The install block is used to install the tools being used.
#   mac: brew install       #   if you don't specify a package for a tool on a given platform
#   win: winget install     #   then it won't be installed there.
#   nix: sudo pacman -S --needed --noconfirm    # You don't need installers on all platforms.
# template:
#   nu:             #<- This is the name of the command to be configured
#     files:        #   configuration won't run if the command is missing from path
#       config.nu:      #<- This is the name of a file in templates/ to be rendered
#         nix: ~/.config/nushell/config.nu          #<- This file goes in different places
#         win: ~/AppData/Roaming/nushell/config.nu  #   depending on the platform.
#       callback: print 'nu configured'             #<- callbacks are run after all
#   wezterm:                                        #   files are rendered for a command.
#     files:
#       wezterm.lua: ~/.config/wezterm/wezterm.lua  #<- This destination doesn't depend
#     package: wezterm                              #   on the platform. Neither does the package.
# ```
def main [
    --config(-c):string,# use an alternate config file.
    --install(-i),      # try to install tools before configuring them.
    --force(-f),        # write files even if the destination has changed unexpectedly.
] {
    let config = setup $config
    # determine the current platform
    # so we can resolve config values that are potentially split across platforms
    let platform = $config.detect | transpose platform cmd |
        where {|row|nu -c $row.cmd|into bool} |
        get 0.platform
    let value = {||if ($in|describe) == 'string' { $in } else {$in | get -i $platform}}

    # flatten command structure and resolve platform values
    let commands = $config.template | transpose name data | flatten data |
        upsert package $value |
        upsert files {|v|if ($v.files? | is-not-empty) {
            $v.files | transpose from to |
            upsert to {||do $value | path expand}
        }} |
        upsert callback $value

    if $install {
        let installer = $config.install | do $value
        if ($installer | is-empty) {
            $'no installer configured for ($platform)' | log -w
            exit 2
        }
        let packages = $commands.package | compact |  str join ' '
        if ($packages != '') { 
            let cmd = $"($installer) ($packages)"
            print $'(ansi blue)INFO(ansi reset): ($cmd)'
            # TODO run install command
            #nu -c $cmd
        }
    }

    let state = (if ($config.state | path exists) { open $config.state | from yaml } else { {} })
    mut changes = {}

    for $command in ($commands | compact files) {
        # don't process commands which aren't installed
        if (which $command.name | is-empty) { continue }
        for $render in $command.files {
            # skip rendering a file if the destination has an unexpected hash
            if not $force and ($render.to | path exists) {
                if (open $render.to | hash md5) != ($state | get -i $render.to)  {
                    print $'(ansi red_bold)WARN(ansi reset): destination ($render.to) has unrecognized changes. skipping'
                    continue
                }
            }
            if not ($render.from | path exists) {
                print $'(ansi red_bold)WARN(ansi reset): template ($render.to|path basename) not found. skipping'
                continue
            }
            print $'(ansi blue)INFO(ansi reset): ($render.from) => ($render.to)'
            # TODO render file
            let rendered = open $render.from

            # write file
            mkdir ($render.to | path dirname)
            $rendered | save -f $render.to

            # record hash
            $changes = $changes | merge {$render.to: ($rendered | hash md5)}
        }
        # wrap up with any callback
        if ($command.callback | is-not-empty) {
            $command.callback | info
            nu -c $command.callback | complete
        }
    }
    # finally update the state file
    $state | merge $changes | to yaml | save -f $config.state
}

# watch the configuration directory and render on write
def "main watch" [--config(-c):string] {
    let $config = setup $config # cd to the target directory
    # TODO: also watch the configuration file itself, not sure how to make that happen
    watch '.' {|op| if $op != 'Remove' { main --config $config.path }}
}

# use the given configuration by default.
#
# This installs a stub at the default configuration path pointing to the given file.
# The real config file can then be stored under version control.
def "main with" [config:string] {
    mkdir ($defaultpath | path expand | path dirname)
    {redirect:($config|path expand)}|to yaml | save -f $defaultpath
    main
}


# determine which config we should use, either from --config or the standard path based on os-info
def --env setup [$configpath] {
    let configpath = $configpath | default $defaultpath | path expand
    mut config = {
        path: $configpath
        state: ($configpath | path parse | update extension 'state' | path join)
    }

    # if redirect to another file if requested.
    # this is so that we can have a stub at the default configuration
    # and then redirect to where our actual configuration is kept under version control
    # the state file is not redirected in the same way, since it shouldn't be under vcs
    mut userdata = {}
    try {
        $userdata = open $config.path
    } catch {
        error make {
            msg: "Configuration file not found."
            label: { text: $configpath span: (metadata $configpath).span }
            help: "Did you mean to pass --config?"
        }
    }
    if ($userdata.redirect? | is-not-empty) and ($userdata.redirect | path exists) {
        $config.path = $userdata.redirect
        $userdata = open $config.path
    }
    $config = $config | merge $userdata

    # paths are expanded relative to the current directory
    # we want to expand the $config.source relative to $config.path
    cd ($config.path | path dirname)
    $config.source = $config.source | default '.' | path expand

    # template names are relative to $config.source, so lets move again
    cd $config.source

    return $config
}
